"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
/**
 * Finds the instances of an executable in the system path.
 */
class Finder {
    /**
     * Value indicating whether the current platform is Windows.
     */
    static get isWindows() {
        if (process.platform == 'win32')
            return true;
        return process.env.OSTYPE == 'cygwin' || process.env.OSTYPE == 'msys';
    }
    /**
     * Creates a new finder.
     * @param options An object specifying values used to initialize this instance.
     */
    constructor(options = {}) {
        // tslint:disable-next-line: prefer-const
        let { extensions = '', path = '', pathSeparator = '' } = options;
        this.pathSeparator = pathSeparator.length ? pathSeparator : (Finder.isWindows ? ';' : path_1.delimiter);
        if (!Array.isArray(path))
            path = path.split(this.pathSeparator).filter(item => item.length > 0);
        if (!path.length) {
            const pathEnv = 'PATH' in process.env ? process.env.PATH : '';
            if (pathEnv.length)
                path = pathEnv.split(this.pathSeparator);
        }
        if (!Array.isArray(extensions))
            extensions = extensions.split(this.pathSeparator).filter(item => item.length > 0);
        if (!extensions.length && Finder.isWindows) {
            const pathExt = 'PATHEXT' in process.env ? process.env.PATHEXT : '';
            extensions = pathExt.length ? pathExt.split(this.pathSeparator) : ['.exe', '.cmd', '.bat', '.com'];
        }
        this.extensions = extensions.map(extension => extension.toLowerCase());
        this.path = path.map(directory => directory.replace(/^"+|"+$/g, ''));
    }
    /**
     * The class name.
     */
    get [Symbol.toStringTag]() {
        return 'Finder';
    }
    /**
     * Finds the instances of an executable in the system path.
     * @param command The command to be resolved.
     * @param all Value indicating whether to return all executables found, or just the first one.
     * @return The paths of the executables found, or an empty array if the command was not found.
     */
    async find(command, all = true) {
        const executables = [];
        for (const path of this.path) {
            executables.push(...await this._findExecutables(path, command, all));
            if (!all && executables.length)
                return executables;
        }
        return [...new Set(executables)];
    }
    /**
     * Gets a value indicating whether the specified file is executable.
     * @param file The path of the file to be checked.
     * @return `true` if the specified file is executable, otherwise `false`.
     */
    async isExecutable(file) {
        try {
            const fileStats = await fs_1.promises.stat(file);
            if (!fileStats.isFile())
                return false;
            return Finder.isWindows ? this._checkFileExtension(file) : this._checkFilePermissions(fileStats);
        }
        catch (_a) {
            return false;
        }
    }
    /**
     * Returns a string representation of this object.
     * @return The string representation of this object.
     */
    toString() {
        const values = [];
        if (this.path.length)
            values.push(`path: "${this.path.join(this.pathSeparator)}"`);
        if (this.extensions.length)
            values.push(`extensions: "${this.extensions.join(this.pathSeparator)}"`);
        return `${this[Symbol.toStringTag]}(${values.join(', ')})`;
    }
    /**
     * Checks that the specified file is executable according to the executable file extensions.
     * @param file The path of the file to be checked.
     * @return Value indicating whether the specified file is executable.
     */
    _checkFileExtension(file) {
        return this.extensions.includes(path_1.extname(file).toLowerCase()) || this.extensions.includes(file.toLowerCase());
    }
    /**
     * Checks that the specified file is executable according to its permissions.
     * @param fileStats A reference to the file to be checked.
     * @return Value indicating whether the specified file is executable.
     */
    _checkFilePermissions(fileStats) {
        // Others.
        const perms = fileStats.mode;
        if (perms & 0o001)
            return true;
        // Group.
        const gid = process.getgid ? process.getgid() : -1;
        if (perms & 0o010)
            return gid == fileStats.gid;
        // Owner.
        const uid = process.getuid ? process.getuid() : -1;
        if (perms & 0o100)
            return uid == fileStats.uid;
        // Root.
        return perms & (0o100 | 0o010) ? uid == 0 : false;
    }
    /**
     * Finds the instances of an executable in the specified directory.
     * @param directory The directory path.
     * @param command The command to be resolved.
     * @param all Value indicating whether to return all executables found, or just the first one.
     * @return The paths of the executables found, or an empty array if the command was not found.
     */
    async _findExecutables(directory, command, all = true) {
        const executables = [];
        for (const extension of [''].concat(this.extensions)) {
            const resolvedPath = path_1.resolve(path_1.join(directory, command) + extension.toLowerCase());
            if (await this.isExecutable(resolvedPath)) {
                executables.push(resolvedPath);
                if (!all)
                    return executables;
            }
        }
        return executables;
    }
}
exports.Finder = Finder;
/**
 * An exception caused by a `Finder` in a command lookup.
 */
class FinderError extends Error {
    /**
     * Creates a new finder error.
     * @param command The looked up command.
     * @param finder The finder used to lookup the command.
     * @param message A message describing the error.
     */
    constructor(command, finder, message = '') {
        super(message);
        this.command = command;
        this.finder = finder;
        this.name = 'FinderError';
    }
    /**
     * Returns a string representation of this object.
     * @return The string representation of this object.
     */
    toString() {
        const values = [`"${this.command}"`];
        if (this.finder.path.length)
            values.push(`finder: "${this.finder.path.join(this.finder.pathSeparator)}"`);
        if (this.message.length)
            values.push(`message: "${this.message}"`);
        return `FinderError(${values.join(', ')})`;
    }
}
exports.FinderError = FinderError;
//# sourceMappingURL=finder.js.map